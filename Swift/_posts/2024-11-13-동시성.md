---
layout: post
title: "Swift의 동시성"
tags:  swift 
excerpt_image: ""
---

동시성은 여러 작업을 병렬로 수행하는 소프트웨어 기능으로 정의할 수 있다 스위프트 언어에서 구조화된 동시성 기능을 살펴보고 이 기능을 이용해서 앱 프로젝트에 멀티태스킹을 지원할 수 있다

### 애플리케이션 메인 스레드

앱이 처음 시작될 때 런타임 시스템은 보통 앱이 기본적으로 실행되는 단일 스레드(메인 스레드)를 생성한다 메인 스레드를 사용해서 시간이 걸리는 작업을 수행하면 화면이 멈춘것처럼 보인다 이 작업을 다른 스레드에서 시작하면 메인 스레드를 계속 사용할 수 있다

&nbsp;

### 구조화된 동시성

구조화된 동시성의 이름이 뭔가 어렵게 느껴지지만 비동기 작업을 더 쉽게 안전하게, 관리 가능하게 처리할 수 있도록 도와주는 개념이다 이 개념은 비동기 작업을 어떻게 시작하고 실행하고 완료할지 명확히 제어할 수 있게 해준다 즉 백그라운드 작업이 언제 종료되는지 어떻게 종료되는지에 대해 걱정하지 않도록 도와준다 (스위프트에서 비동기 함수를 작성하는 방법이라고 생각하면 될것 같다)

&nbsp;

### 동기 코드

동기 코드는 비동기 코드의 반대로 코드를 직접 실행해서 확인해본다

``` swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        Button(action: {
            doSomething()
        }){
            Text("do something")
        }
    }
    
    func doSomething() {
        print("Start \(Date())")
        tasksTooLong()
        print("End \(Date())")
    }
    func tasksTooLong() {
        sleep(5)
        print("complete task at \(Date())")
    }
}
```

<center>
<img src="https://github.com/user-attachments/assets/90231fce-a2ba-47e4-844b-d7008b3fbcbc" style="zoom:50%;">
</center>

종료 시간이 5초 이류 이다 tasksTooLong이 지속되는 5초간에 이후 함수들이 호출되지 않는다 사용자에게는 5초간 화면이 멈춘것 처럼 보인다

&nbsp;

### async/await

구조화된 동시성의 기초는 async/await쌍이다 async 키워드는 함수가 호출된 스레드에 대해 비동기적으로 실행됨을 나타내기 위해 함수를 선언할 때 사용한다 (*호출된 함수가 다른 스레드에서 실행*) 이렇게 선언된 함수들은 await 키워드를 통해서만 호출될 수 있다

``` swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        Button(action: {
            Task{
                await doSomething()
            }
        }){
            Text("do something")
        }
    }
    
    func doSomething() async {
        print("Start \(Date())")
        await  tasksTooLong()
        print("End \(Date())")
    }
    func tasksTooLong() async {
        sleep(5)
        print("complete task at \(Date())")
    }
}
```

<center>
<img src="https://github.com/user-attachments/assets/60d5ed65-1041-4fb3-bb6d-1798bb1b12fe" style="zoom:50%;">
</center>

이번 결과는 이전 결과와 똑같이 5초뒤에 끝이 났다 doSomethong함수가 계속 진행되지 못하고 tasksTooLong함수가 반환될 때 까지 기다려야하기 때문에 작업을 호출한 스레드를 여전히 차단하고 있다는 느낌을 준다 (부모 비동기 함수는 모든 하위 함수가 완료될 때까지 완료할 수 없기 때문이다)

**async-let**을 사용한다면 부모 함수에서 기다리는 것을 나중으로 미룰 수 있다

&nbsp;

### async-let 바인딩 사용

 
