---
layout: post
title: "this"
date:   2023-01-10 16:35:47 +0900
categories:
tags: this binding 바인딩
---

자바스크립트에서 this가 참조되는것은 호출에따라 달라지는데 이것을 this 바인딩이라고 한다

``` js
function foo() {
  const a = 10;
  console.log(this.a);
}

foo(); 
```

실행 결과값이 10이 나올줄 알았지만 console에 보이는 값은 undefined 이다

this가 어디에 바인딩되는지 알기위해서 4가지 규칙을 알면 헷갈리지 않고 this를 알 수 있다

&nbsp;

&nbsp;

### 기본 바인딩

기본 바인딩은 나머지 4가지 규칙에 포함되지 않는 경우 기본값으로 실행되는 바인딩이다 이때 this는 전역 객체에 바인딩된다 (브라우저면 window node.js이면 global)

&nbsp;

``` js
function foo() {
  const a = 10;
  console.log(this.a);
}

foo(); //undefined
```

여기서는 window에 a라는 프로퍼티가 없어서 undefined가 출력 되었다

&nbsp;

```js
window.a=100
function foo() {
  const a = 10;
  console.log(this.a);
}

foo();//100
```

this.a는 전역 객체의 a를 의미하기 때문에 10이 출력되지 않고 100이 출력된다

&nbsp;

``` js
'use strict'
window.a = 20;

function foo() {
  console.log(this.a);
}

foo(); // Uncaught TypeError: Cannot read properties of undefined (reading 'a')
```

엄격모드에서는 기본 바인딩 대상에서 전역 객체는 제외된다 전역객체를 참조하면 그 값은 undefined

&nbsp;

&nbsp;

### 암시적 바인딩

함수가 객체의 메서드로 호출될 때 this가 바인딩 되는것이다 이때 this는 해당 함수를 호출한 객체 컨텍스트 객체에 바인딩된다

``` js
function foo() {
    console.log(this.name);
}

var person = {
    name: '철수',
    foo: foo
};

person.foo(); //철수 여기서 person에 바인딩 된다

const foo = {
  a: 20,
  bar: function () {
    console.log(this.a);
  }
}

foo.bar(); // 20 foo에 바인딩된다
```

해당 함수를 호출한 객체 person과 foo에 바인딩 된다

&nbsp;

#### 암시적 소실

암시적 바인딩을 사용할때 일어날 수 있는 문제점은 foo.bar를 매개변수로 넘겨서 실행할 때 생긴다

``` js
const foo = {
		a: 20,
		bar: function () {
		  console.log(this.a);
		}
	  }
	  
setTimeout(foo.bar, 1000);//undefined
```

setTimeout 함수에 foo.bar가 매개변수로 들어간다 1초뒤에 콘솔에 20이 나올 것이라고 예상했다 하지만 undefined가 출력 되었다

암시적 바인딩이 적용된 콜백함수를 인자로 넘긴다고 해도 위 setTimeout에 전달한 콜백은 bar라는 레퍼런스이다 따라서 foo 컨텍스트 객체의 정보를 가지지 않기 때문에 암시적 바인딩이 소실되었고 그래서 기본 바인딩이 적용되었다

전역 변수에 bar라는 프로퍼티가 없어서 undefined가 출력되었다

&nbsp;

&nbsp;

### 명시적 바인딩

자바스크립트의 모든 함수는 call(), apply(), bind()를 메서드로 가지고 있다 이 세개중 하나를 호출해서 this바인딩을 코드에 명시하는것을 명시적 바인딩이라고 한다

#### call(), apply()

``` js
const foo = {
  a: 20,
}

function bar() {
  console.log(this.a);
}

bar.call(foo); // 20
bar.apply(foo); // 20
```

bar에서 사용된 this는 foo에 명시적으로 바인딩 된다 컨텍스트가 foo가 된다

call과 apply는 두번째 매개변수로 객체의 인자를 전달하는데 call은 매개변수의 목록, apply는 매개변수의 배열을 받는다

&nbsp;

#### bind()

``` js
const foo = {
  a: 20,
}

function bar() {
  console.log(this.a);
}

const bound = bar.bind(foo)

bound(); // 20
```

bind메서드를 이용하면 this가 바인딩된 함수를 반환한다 이를 하드 바인딩이라고 하고 이후 호출 될때마다 처음 정해진 this바인딩을 가지고 호출된다

``` js
function foo() {
    console.log(this.name);
}

var person = {
    name: '철수's
};

// 하드 바인딩
var bar = function () {
    foo.call(person);
};

bar(); // 철수
setTimeout(bar, 1000); // 철수
bar.call(window); // 철수, foo에는 명시적 바인딩이 적용되지 않는다.
```

만약 bar.call(window);에 명시적 바인딩이 적용되었다면 undefined가 출력 되었을것이다 

&nbsp;

&nbsp;

### new 바인딩

new 키워드는 함수를 호출할 때 객체를 초기화시킨다 이 때 사용되는 함수를 생성자 함수라고 한다(생성자 함수는 대문자시작)

생성자 함수에서 this를 이용해서 생성할 객체의 참조로 이용된다

``` js
function Foo() { //생성자 함수
  this.a = 20;
}

const foo = new Foo();

console.log(foo.a); // 20
```

Foo함수가 new로 호출될때 새로운 객체가 생성되고 새로 생성된 객체가 this 바인딩된다 foo라는 객체에 a프로퍼티 20이 저장된다

&nbsp;

&nbsp;

### 바인딩 순서

1. new 바인딩
2. 명시적 바인딩
3. 암시적 바인딩
4. 기본 바인딩

&nbsp;

&nbsp;

### this 무시

명시적 바인딩이 이루어질때 call(), apply(), bind()의 첫번째 인자로 null, undefined가 입력되면 명시적 바인딩이 무시되고 기본 바인딩이 이루어진다

&nbsp;

&nbsp;

### 화살표 함수

일반적으로 함수들은 4가지 규칙을 준수하지만 ES6부터 규칙을 따르지 않는 화살표 함수가 등장 했다 화살표 함수는 함수,전역으로부터 어떤 값이든간에  this바인딩을 상속한다

**화살표 함수의 this는 항상 선언된 위치에서 컨텍스트 객체가 this에 바인딩 된다 **

``` js
function foo() {
		setTimeout(() => {
			// this는 foo() 함수로부터 lexical 바인딩된다.
			console.log(this.name);
		}, 1000);
	}
	
	const bar = {
		name: '철수'
	};
	
	foo.call(bar); // 철수
```

화살표 함수의 렉시컬 바인딩은 절대 오버라이드 될 수 없다 ---

this를 확실하게 보장하기 때문에 콜백 함수로 많이 이용된다



